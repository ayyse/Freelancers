import { HttpClient, HttpParams } from '@angular/common/http';
import { Inject, Injectable } from '@angular/core';
import { throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { ExternalHttpClient } from '../clients/http.client';
import { CORE_OPTIONS } from '../tokens/options.token';
import { isUndefinedOrEmptyString } from '../utils/common-utils';
import { EnvironmentService } from './environment.service';
import { HttpErrorReporterService } from './http-error-reporter.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "../clients/http.client";
import * as i3 from "./environment.service";
import * as i4 from "./http-error-reporter.service";
export class RestService {
    constructor(options, http, externalHttp, environment, httpErrorReporter) {
        this.options = options;
        this.http = http;
        this.externalHttp = externalHttp;
        this.environment = environment;
        this.httpErrorReporter = httpErrorReporter;
    }
    getApiFromStore(apiName) {
        return this.environment.getApiUrl(apiName);
    }
    handleError(err) {
        this.httpErrorReporter.reportError(err);
        return throwError(() => err);
    }
    request(request, config, api) {
        config = config || {};
        api = api || this.getApiFromStore(config.apiName);
        const { method, params, ...options } = request;
        const { observe = "body" /* Rest.Observe.Body */, skipHandleError } = config;
        const url = this.removeDuplicateSlashes(api + request.url);
        const httpClient = this.getHttpClient(config.skipAddingHeader);
        return httpClient
            .request(method, url, {
            observe,
            ...(params && {
                params: this.getParams(params, config.httpParamEncoder),
            }),
            ...options,
        })
            .pipe(catchError(err => (skipHandleError ? throwError(() => err) : this.handleError(err))));
    }
    getHttpClient(isExternal) {
        return isExternal ? this.externalHttp : this.http;
    }
    getParams(params, encoder) {
        const filteredParams = Object.entries(params).reduce((acc, [key, value]) => {
            if (isUndefinedOrEmptyString(value))
                return acc;
            if (value === null && !this.options.sendNullsAsQueryParam)
                return acc;
            acc[key] = value;
            return acc;
        }, {});
        return encoder
            ? new HttpParams({ encoder, fromObject: filteredParams })
            : new HttpParams({ fromObject: filteredParams });
    }
    removeDuplicateSlashes(url) {
        return url.replace(/([^:]\/)\/+/g, '$1');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: RestService, deps: [{ token: CORE_OPTIONS }, { token: i1.HttpClient }, { token: i2.ExternalHttpClient }, { token: i3.EnvironmentService }, { token: i4.HttpErrorReporterService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: RestService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: RestService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [CORE_OPTIONS]
                }] }, { type: i1.HttpClient }, { type: i2.ExternalHttpClient }, { type: i3.EnvironmentService }, { type: i4.HttpErrorReporterService }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzdC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvbGliL3NlcnZpY2VzL3Jlc3Quc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFzQixVQUFVLEVBQWUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvRixPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQWMsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzlDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM1QyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUc1RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDdkQsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDakUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDM0QsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sK0JBQStCLENBQUM7Ozs7OztBQUt6RSxNQUFNLE9BQU8sV0FBVztJQUN0QixZQUNrQyxPQUFpQixFQUN2QyxJQUFnQixFQUNoQixZQUFnQyxFQUNoQyxXQUErQixFQUMvQixpQkFBMkM7UUFKckIsWUFBTyxHQUFQLE9BQU8sQ0FBVTtRQUN2QyxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLGlCQUFZLEdBQVosWUFBWSxDQUFvQjtRQUNoQyxnQkFBVyxHQUFYLFdBQVcsQ0FBb0I7UUFDL0Isc0JBQWlCLEdBQWpCLGlCQUFpQixDQUEwQjtJQUNuRCxDQUFDO0lBRUssZUFBZSxDQUFDLE9BQTJCO1FBQ25ELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELFdBQVcsQ0FBQyxHQUFRO1FBQ2xCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEMsT0FBTyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVELE9BQU8sQ0FDTCxPQUF5QyxFQUN6QyxNQUFvQixFQUNwQixHQUFZO1FBRVosTUFBTSxHQUFHLE1BQU0sSUFBSyxFQUFrQixDQUFDO1FBQ3ZDLEdBQUcsR0FBRyxHQUFHLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbEQsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxPQUFPLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDL0MsTUFBTSxFQUFFLE9BQU8saUNBQW9CLEVBQUUsZUFBZSxFQUFFLEdBQUcsTUFBTSxDQUFDO1FBQ2hFLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTNELE1BQU0sVUFBVSxHQUFlLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDM0UsT0FBTyxVQUFVO2FBQ2QsT0FBTyxDQUFJLE1BQU0sRUFBRSxHQUFHLEVBQUU7WUFDdkIsT0FBTztZQUNQLEdBQUcsQ0FBQyxNQUFNLElBQUk7Z0JBQ1osTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQzthQUN4RCxDQUFDO1lBQ0YsR0FBRyxPQUFPO1NBQ0osQ0FBQzthQUNSLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hHLENBQUM7SUFDTyxhQUFhLENBQUMsVUFBbUI7UUFDdkMsT0FBTyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDcEQsQ0FBQztJQUVPLFNBQVMsQ0FBQyxNQUFtQixFQUFFLE9BQTRCO1FBQ2pFLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDekUsSUFBSSx3QkFBd0IsQ0FBQyxLQUFLLENBQUM7Z0JBQUUsT0FBTyxHQUFHLENBQUM7WUFDaEQsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxxQkFBcUI7Z0JBQUUsT0FBTyxHQUFHLENBQUM7WUFDdEUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztZQUNqQixPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxFQUFTLENBQUMsQ0FBQztRQUNkLE9BQU8sT0FBTztZQUNaLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLENBQUM7WUFDekQsQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUM7SUFDckQsQ0FBQztJQUVPLHNCQUFzQixDQUFDLEdBQVc7UUFDeEMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMzQyxDQUFDOzhHQTFEVSxXQUFXLGtCQUVaLFlBQVk7a0hBRlgsV0FBVyxjQUZWLE1BQU07OzJGQUVQLFdBQVc7a0JBSHZCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzswQkFHSSxNQUFNOzJCQUFDLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwQ2xpZW50LCBIdHRwUGFyYW1ldGVyQ29kZWMsIEh0dHBQYXJhbXMsIEh0dHBSZXF1ZXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xyXG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBFeHRlcm5hbEh0dHBDbGllbnQgfSBmcm9tICcuLi9jbGllbnRzL2h0dHAuY2xpZW50JztcclxuaW1wb3J0IHsgQUJQIH0gZnJvbSAnLi4vbW9kZWxzL2NvbW1vbic7XHJcbmltcG9ydCB7IFJlc3QgfSBmcm9tICcuLi9tb2RlbHMvcmVzdCc7XHJcbmltcG9ydCB7IENPUkVfT1BUSU9OUyB9IGZyb20gJy4uL3Rva2Vucy9vcHRpb25zLnRva2VuJztcclxuaW1wb3J0IHsgaXNVbmRlZmluZWRPckVtcHR5U3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMvY29tbW9uLXV0aWxzJztcclxuaW1wb3J0IHsgRW52aXJvbm1lbnRTZXJ2aWNlIH0gZnJvbSAnLi9lbnZpcm9ubWVudC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSHR0cEVycm9yUmVwb3J0ZXJTZXJ2aWNlIH0gZnJvbSAnLi9odHRwLWVycm9yLXJlcG9ydGVyLnNlcnZpY2UnO1xyXG5cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIFJlc3RTZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBJbmplY3QoQ09SRV9PUFRJT05TKSBwcm90ZWN0ZWQgb3B0aW9uczogQUJQLlJvb3QsXHJcbiAgICBwcm90ZWN0ZWQgaHR0cDogSHR0cENsaWVudCxcclxuICAgIHByb3RlY3RlZCBleHRlcm5hbEh0dHA6IEV4dGVybmFsSHR0cENsaWVudCxcclxuICAgIHByb3RlY3RlZCBlbnZpcm9ubWVudDogRW52aXJvbm1lbnRTZXJ2aWNlLFxyXG4gICAgcHJvdGVjdGVkIGh0dHBFcnJvclJlcG9ydGVyOiBIdHRwRXJyb3JSZXBvcnRlclNlcnZpY2UsXHJcbiAgKSB7IH1cclxuXHJcbiAgcHJvdGVjdGVkIGdldEFwaUZyb21TdG9yZShhcGlOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuZW52aXJvbm1lbnQuZ2V0QXBpVXJsKGFwaU5hbWUpO1xyXG4gIH1cclxuXHJcbiAgaGFuZGxlRXJyb3IoZXJyOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG4gICAgdGhpcy5odHRwRXJyb3JSZXBvcnRlci5yZXBvcnRFcnJvcihlcnIpO1xyXG4gICAgcmV0dXJuIHRocm93RXJyb3IoKCkgPT4gZXJyKTtcclxuICB9XHJcblxyXG4gIHJlcXVlc3Q8VCwgUj4oXHJcbiAgICByZXF1ZXN0OiBIdHRwUmVxdWVzdDxUPiB8IFJlc3QuUmVxdWVzdDxUPixcclxuICAgIGNvbmZpZz86IFJlc3QuQ29uZmlnLFxyXG4gICAgYXBpPzogc3RyaW5nLFxyXG4gICk6IE9ic2VydmFibGU8Uj4ge1xyXG4gICAgY29uZmlnID0gY29uZmlnIHx8ICh7fSBhcyBSZXN0LkNvbmZpZyk7XHJcbiAgICBhcGkgPSBhcGkgfHwgdGhpcy5nZXRBcGlGcm9tU3RvcmUoY29uZmlnLmFwaU5hbWUpO1xyXG4gICAgY29uc3QgeyBtZXRob2QsIHBhcmFtcywgLi4ub3B0aW9ucyB9ID0gcmVxdWVzdDtcclxuICAgIGNvbnN0IHsgb2JzZXJ2ZSA9IFJlc3QuT2JzZXJ2ZS5Cb2R5LCBza2lwSGFuZGxlRXJyb3IgfSA9IGNvbmZpZztcclxuICAgIGNvbnN0IHVybCA9IHRoaXMucmVtb3ZlRHVwbGljYXRlU2xhc2hlcyhhcGkgKyByZXF1ZXN0LnVybCk7XHJcblxyXG4gICAgY29uc3QgaHR0cENsaWVudDogSHR0cENsaWVudCA9IHRoaXMuZ2V0SHR0cENsaWVudChjb25maWcuc2tpcEFkZGluZ0hlYWRlcik7XHJcbiAgICByZXR1cm4gaHR0cENsaWVudFxyXG4gICAgICAucmVxdWVzdDxSPihtZXRob2QsIHVybCwge1xyXG4gICAgICAgIG9ic2VydmUsXHJcbiAgICAgICAgLi4uKHBhcmFtcyAmJiB7XHJcbiAgICAgICAgICBwYXJhbXM6IHRoaXMuZ2V0UGFyYW1zKHBhcmFtcywgY29uZmlnLmh0dHBQYXJhbUVuY29kZXIpLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIH0gYXMgYW55KVxyXG4gICAgICAucGlwZShjYXRjaEVycm9yKGVyciA9PiAoc2tpcEhhbmRsZUVycm9yID8gdGhyb3dFcnJvcigoKSA9PiBlcnIpIDogdGhpcy5oYW5kbGVFcnJvcihlcnIpKSkpO1xyXG4gIH1cclxuICBwcml2YXRlIGdldEh0dHBDbGllbnQoaXNFeHRlcm5hbDogYm9vbGVhbikge1xyXG4gICAgcmV0dXJuIGlzRXh0ZXJuYWwgPyB0aGlzLmV4dGVybmFsSHR0cCA6IHRoaXMuaHR0cDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0UGFyYW1zKHBhcmFtczogUmVzdC5QYXJhbXMsIGVuY29kZXI/OiBIdHRwUGFyYW1ldGVyQ29kZWMpOiBIdHRwUGFyYW1zIHtcclxuICAgIGNvbnN0IGZpbHRlcmVkUGFyYW1zID0gT2JqZWN0LmVudHJpZXMocGFyYW1zKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XHJcbiAgICAgIGlmIChpc1VuZGVmaW5lZE9yRW1wdHlTdHJpbmcodmFsdWUpKSByZXR1cm4gYWNjO1xyXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgIXRoaXMub3B0aW9ucy5zZW5kTnVsbHNBc1F1ZXJ5UGFyYW0pIHJldHVybiBhY2M7XHJcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LCB7fSBhcyBhbnkpO1xyXG4gICAgcmV0dXJuIGVuY29kZXJcclxuICAgICAgPyBuZXcgSHR0cFBhcmFtcyh7IGVuY29kZXIsIGZyb21PYmplY3Q6IGZpbHRlcmVkUGFyYW1zIH0pXHJcbiAgICAgIDogbmV3IEh0dHBQYXJhbXMoeyBmcm9tT2JqZWN0OiBmaWx0ZXJlZFBhcmFtcyB9KTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcmVtb3ZlRHVwbGljYXRlU2xhc2hlcyh1cmw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLyhbXjpdXFwvKVxcLysvZywgJyQxJyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==