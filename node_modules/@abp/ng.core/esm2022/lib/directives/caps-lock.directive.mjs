import { Directive, EventEmitter, HostListener, Output } from '@angular/core';
import * as i0 from "@angular/core";
export class TrackCapsLockDirective {
    constructor() {
        this.capsLock = new EventEmitter();
    }
    onKeyDown(event) {
        this.capsLock.emit(this.isCapsLockOpen(event));
    }
    onKeyUp(event) {
        this.capsLock.emit(this.isCapsLockOpen(event));
    }
    isCapsLockOpen(e) {
        const s = String.fromCharCode(e.which);
        if ((s.toUpperCase() === s && s.toLowerCase() !== s && e.shiftKey) ||
            (s.toUpperCase() !== s && s.toLowerCase() === s && e.shiftKey) ||
            (e.getModifierState && e.getModifierState('CapsLock'))) {
            return true;
        }
        return false;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: TrackCapsLockDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.5", type: TrackCapsLockDirective, isStandalone: true, selector: "[abpCapsLock]", outputs: { capsLock: "abpCapsLock" }, host: { listeners: { "window:keydown": "onKeyDown($event)", "window:keyup": "onKeyUp($event)" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: TrackCapsLockDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[abpCapsLock]',
                }]
        }], propDecorators: { capsLock: [{
                type: Output,
                args: ['abpCapsLock']
            }], onKeyDown: [{
                type: HostListener,
                args: ['window:keydown', ['$event']]
            }], onKeyUp: [{
                type: HostListener,
                args: ['window:keyup', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fwcy1sb2NrLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2xpYi9kaXJlY3RpdmVzL2NhcHMtbG9jay5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQzs7QUFNOUUsTUFBTSxPQUFPLHNCQUFzQjtJQUpuQztRQUt5QixhQUFRLEdBQUcsSUFBSSxZQUFZLEVBQVcsQ0FBQztLQXNCL0Q7SUFuQkMsU0FBUyxDQUFDLEtBQW9CO1FBQzVCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQsT0FBTyxDQUFDLEtBQW9CO1FBQzFCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQsY0FBYyxDQUFDLENBQUM7UUFDZCxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN2QyxJQUNFLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDOUQsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQztZQUM5RCxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUMsRUFDdEQsQ0FBQztZQUNELE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQzs4R0F0QlUsc0JBQXNCO2tHQUF0QixzQkFBc0I7OzJGQUF0QixzQkFBc0I7a0JBSmxDLFNBQVM7bUJBQUM7b0JBQ1QsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLFFBQVEsRUFBRSxlQUFlO2lCQUMxQjs4QkFFd0IsUUFBUTtzQkFBOUIsTUFBTTt1QkFBQyxhQUFhO2dCQUdyQixTQUFTO3NCQURSLFlBQVk7dUJBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxRQUFRLENBQUM7Z0JBSzFDLE9BQU87c0JBRE4sWUFBWTt1QkFBQyxjQUFjLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHN0YW5kYWxvbmU6IHRydWUsXHJcbiAgc2VsZWN0b3I6ICdbYWJwQ2Fwc0xvY2tdJyxcclxufSlcclxuZXhwb3J0IGNsYXNzIFRyYWNrQ2Fwc0xvY2tEaXJlY3RpdmUge1xyXG4gIEBPdXRwdXQoJ2FicENhcHNMb2NrJykgY2Fwc0xvY2sgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzprZXlkb3duJywgWyckZXZlbnQnXSlcclxuICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuICAgIHRoaXMuY2Fwc0xvY2suZW1pdCh0aGlzLmlzQ2Fwc0xvY2tPcGVuKGV2ZW50KSk7XHJcbiAgfVxyXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzprZXl1cCcsIFsnJGV2ZW50J10pXHJcbiAgb25LZXlVcChldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgdGhpcy5jYXBzTG9jay5lbWl0KHRoaXMuaXNDYXBzTG9ja09wZW4oZXZlbnQpKTtcclxuICB9XHJcblxyXG4gIGlzQ2Fwc0xvY2tPcGVuKGUpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpO1xyXG4gICAgaWYgKFxyXG4gICAgICAocy50b1VwcGVyQ2FzZSgpID09PSBzICYmIHMudG9Mb3dlckNhc2UoKSAhPT0gcyAmJiBlLnNoaWZ0S2V5KSB8fFxyXG4gICAgICAocy50b1VwcGVyQ2FzZSgpICE9PSBzICYmIHMudG9Mb3dlckNhc2UoKSA9PT0gcyAmJiBlLnNoaWZ0S2V5KSB8fFxyXG4gICAgICAoZS5nZXRNb2RpZmllclN0YXRlICYmIGUuZ2V0TW9kaWZpZXJTdGF0ZSgnQ2Fwc0xvY2snKSlcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuIl19