import { Directive, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import { fromEvent } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { SubscriptionService } from '../services/subscription.service';
import * as i0 from "@angular/core";
import * as i1 from "../services/subscription.service";
export class InputEventDebounceDirective {
    constructor(el, subscription) {
        this.el = el;
        this.subscription = subscription;
        this.debounce = 300;
        this.debounceEvent = new EventEmitter();
    }
    ngOnInit() {
        const input$ = fromEvent(this.el.nativeElement, 'input').pipe(debounceTime(this.debounce));
        this.subscription.addOne(input$, (event) => {
            this.debounceEvent.emit(event);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: InputEventDebounceDirective, deps: [{ token: i0.ElementRef }, { token: i1.SubscriptionService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.5", type: InputEventDebounceDirective, isStandalone: true, selector: "[input.debounce]", inputs: { debounce: "debounce" }, outputs: { debounceEvent: "input.debounce" }, providers: [SubscriptionService], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: InputEventDebounceDirective, decorators: [{
            type: Directive,
            args: [{
                    standalone: true,
                    selector: '[input.debounce]',
                    providers: [SubscriptionService],
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.SubscriptionService }], propDecorators: { debounce: [{
                type: Input
            }], debounceEvent: [{
                type: Output,
                args: ['input.debounce']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVib3VuY2UuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvbGliL2RpcmVjdGl2ZXMvZGVib3VuY2UuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQVUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNGLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDakMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDOzs7QUFPdkUsTUFBTSxPQUFPLDJCQUEyQjtJQUt0QyxZQUFvQixFQUFjLEVBQVUsWUFBaUM7UUFBekQsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQUFVLGlCQUFZLEdBQVosWUFBWSxDQUFxQjtRQUpwRSxhQUFRLEdBQUcsR0FBRyxDQUFDO1FBRVcsa0JBQWEsR0FBRyxJQUFJLFlBQVksRUFBUyxDQUFDO0lBRUcsQ0FBQztJQUVqRixRQUFRO1FBQ04sTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFhLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FDdkUsWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FDNUIsQ0FBQztRQUVGLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEtBQVksRUFBRSxFQUFFO1lBQ2hELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs4R0FmVSwyQkFBMkI7a0dBQTNCLDJCQUEyQiwrSUFGM0IsQ0FBQyxtQkFBbUIsQ0FBQzs7MkZBRXJCLDJCQUEyQjtrQkFMdkMsU0FBUzttQkFBQztvQkFDVCxVQUFVLEVBQUUsSUFBSTtvQkFDaEIsUUFBUSxFQUFFLGtCQUFrQjtvQkFDNUIsU0FBUyxFQUFFLENBQUMsbUJBQW1CLENBQUM7aUJBQ2pDO2lIQUVVLFFBQVE7c0JBQWhCLEtBQUs7Z0JBRTZCLGFBQWE7c0JBQS9DLE1BQU07dUJBQUMsZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvc3Vic2NyaXB0aW9uLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcclxuICBzZWxlY3RvcjogJ1tpbnB1dC5kZWJvdW5jZV0nLFxyXG4gIHByb3ZpZGVyczogW1N1YnNjcmlwdGlvblNlcnZpY2VdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgSW5wdXRFdmVudERlYm91bmNlRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0IHtcclxuICBASW5wdXQoKSBkZWJvdW5jZSA9IDMwMDtcclxuXHJcbiAgQE91dHB1dCgnaW5wdXQuZGVib3VuY2UnKSByZWFkb25seSBkZWJvdW5jZUV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjxFdmVudD4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZiwgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblNlcnZpY2UpIHt9XHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgY29uc3QgaW5wdXQkID0gZnJvbUV2ZW50PElucHV0RXZlbnQ+KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2lucHV0JykucGlwZShcclxuICAgICAgZGVib3VuY2VUaW1lKHRoaXMuZGVib3VuY2UpLFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi5hZGRPbmUoaW5wdXQkLCAoZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgIHRoaXMuZGVib3VuY2VFdmVudC5lbWl0KGV2ZW50KTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXX0=