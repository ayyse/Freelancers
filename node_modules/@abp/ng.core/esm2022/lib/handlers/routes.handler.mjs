import { Injectable, Optional } from '@angular/core';
import { Router } from '@angular/router';
import { RoutesService } from '../services/routes.service';
import * as i0 from "@angular/core";
import * as i1 from "../services/routes.service";
import * as i2 from "@angular/router";
export class RoutesHandler {
    constructor(routes, router) {
        this.routes = routes;
        this.router = router;
        this.addRoutes();
    }
    addRoutes() {
        this.router?.config?.forEach(({ path = '', data }) => {
            const routes = data?.routes;
            if (!routes)
                return;
            if (Array.isArray(routes)) {
                this.routes.add(routes);
            }
            else {
                const routesFlatten = flatRoutes([{ path, ...routes }], { path: '' });
                this.routes.add(routesFlatten);
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: RoutesHandler, deps: [{ token: i1.RoutesService }, { token: i2.Router, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: RoutesHandler, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.5", ngImport: i0, type: RoutesHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [{ type: i1.RoutesService }, { type: i2.Router, decorators: [{
                    type: Optional
                }] }] });
function flatRoutes(routes, parent) {
    if (!routes)
        return [];
    return routes.reduce((acc, route) => {
        const { children, ...current } = {
            ...route,
            parentName: parent.name,
            path: (parent.path + '/' + route.path).replace(/\/\//g, '/'),
        };
        acc.push(current, ...flatRoutes(children, current));
        return acc;
    }, []);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVzLmhhbmRsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9saWIvaGFuZGxlcnMvcm91dGVzLmhhbmRsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckQsT0FBTyxFQUFTLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRWhELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQzs7OztBQUszRCxNQUFNLE9BQU8sYUFBYTtJQUN4QixZQUFvQixNQUFxQixFQUFzQixNQUFjO1FBQXpELFdBQU0sR0FBTixNQUFNLENBQWU7UUFBc0IsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUMzRSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVELFNBQVM7UUFDTixJQUFJLENBQUMsTUFBTSxFQUFFLE1BQXNCLEVBQUUsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFLElBQUksRUFBYSxFQUFFLEVBQUU7WUFDL0UsTUFBTSxNQUFNLEdBQUcsSUFBSSxFQUFFLE1BQU0sQ0FBQztZQUM1QixJQUFJLENBQUMsTUFBTTtnQkFBRSxPQUFPO1lBRXBCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO2dCQUMxQixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUMxQixDQUFDO2lCQUFNLENBQUM7Z0JBQ04sTUFBTSxhQUFhLEdBQUcsVUFBVSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ3RFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ2pDLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7OEdBakJVLGFBQWE7a0hBQWIsYUFBYSxjQUZaLE1BQU07OzJGQUVQLGFBQWE7a0JBSHpCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzswQkFFNkMsUUFBUTs7QUFtQnRELFNBQVMsVUFBVSxDQUFDLE1BQWtCLEVBQUUsTUFBVztJQUNqRCxJQUFJLENBQUMsTUFBTTtRQUFFLE9BQU8sRUFBRSxDQUFDO0lBRXZCLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsRUFBRTtRQUNsQyxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxFQUFFLEdBQUc7WUFDL0IsR0FBRyxLQUFLO1lBQ1IsVUFBVSxFQUFFLE1BQU0sQ0FBQyxJQUFJO1lBQ3ZCLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQztTQUM3RCxDQUFDO1FBRUYsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxVQUFVLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFFcEQsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDLEVBQUUsRUFBaUIsQ0FBQyxDQUFDO0FBQ3hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBSb3V0ZSwgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgQUJQIH0gZnJvbSAnLi4vbW9kZWxzJztcclxuaW1wb3J0IHsgUm91dGVzU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3JvdXRlcy5zZXJ2aWNlJztcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCcsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBSb3V0ZXNIYW5kbGVyIHtcclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJvdXRlczogUm91dGVzU2VydmljZSwgQE9wdGlvbmFsKCkgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcikge1xyXG4gICAgdGhpcy5hZGRSb3V0ZXMoKTtcclxuICB9XHJcblxyXG4gIGFkZFJvdXRlcygpIHtcclxuICAgICh0aGlzLnJvdXRlcj8uY29uZmlnIGFzIFJvdXRlRGF0YVtdKT8uZm9yRWFjaCgoeyBwYXRoID0gJycsIGRhdGEgfTogUm91dGVEYXRhKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJvdXRlcyA9IGRhdGE/LnJvdXRlcztcclxuICAgICAgaWYgKCFyb3V0ZXMpIHJldHVybjtcclxuXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvdXRlcykpIHtcclxuICAgICAgICB0aGlzLnJvdXRlcy5hZGQocm91dGVzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCByb3V0ZXNGbGF0dGVuID0gZmxhdFJvdXRlcyhbeyBwYXRoLCAuLi5yb3V0ZXMgfV0sIHsgcGF0aDogJycgfSk7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXMuYWRkKHJvdXRlc0ZsYXR0ZW4pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZsYXRSb3V0ZXMocm91dGVzOiBSb3V0ZURlZltdLCBwYXJlbnQ6IGFueSkge1xyXG4gIGlmICghcm91dGVzKSByZXR1cm4gW107XHJcblxyXG4gIHJldHVybiByb3V0ZXMucmVkdWNlKChhY2MsIHJvdXRlKSA9PiB7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5jdXJyZW50IH0gPSB7XHJcbiAgICAgIC4uLnJvdXRlLFxyXG4gICAgICBwYXJlbnROYW1lOiBwYXJlbnQubmFtZSxcclxuICAgICAgcGF0aDogKHBhcmVudC5wYXRoICsgJy8nICsgcm91dGUucGF0aCkucmVwbGFjZSgvXFwvXFwvL2csICcvJyksXHJcbiAgICB9O1xyXG5cclxuICAgIGFjYy5wdXNoKGN1cnJlbnQsIC4uLmZsYXRSb3V0ZXMoY2hpbGRyZW4sIGN1cnJlbnQpKTtcclxuXHJcbiAgICByZXR1cm4gYWNjO1xyXG4gIH0sIFtdIGFzIEFCUC5Sb3V0ZVtdKTtcclxufVxyXG5cclxudHlwZSBSb3V0ZURlZiA9IEFCUC5Sb3V0ZSAmIHsgY2hpbGRyZW46IFJvdXRlRGVmW10gfTtcclxudHlwZSBSb3V0ZURhdGEgPSBSb3V0ZSAmIHsgZGF0YTogeyByb3V0ZXM6IFJvdXRlRGVmIHwgQXJyYXk8Um91dGVEZWY+IH0gfTtcclxuIl19