export declare class BaseTreeNode<T extends object> {
    children: TreeNode<T>[];
    isLeaf: boolean;
    parent?: TreeNode<T>;
    constructor(props: T);
    static create<T extends object>(props: T): TreeNode<T>;
}
export declare function createTreeFromList<T extends object, R>(list: T[], keySelector: (item: T) => NodeKey, parentKeySelector: typeof keySelector, valueMapper: (item: T) => R): R[];
export declare function createMapFromList<T extends object, R>(list: T[], keySelector: (item: T) => NodeKey, valueMapper: (item: T) => R): Map<NodeKey, R>;
export declare function createTreeNodeFilterCreator<T extends object>(key: keyof T, mapperFn: (value: any) => string): (search: string) => (nodes: TreeNode<T>[], matches?: TreeNode<T>[]) => TreeNode<T>[];
export declare function createGroupMap<T extends {
    group?: string;
}>(list: TreeNode<T>[], othersGroupKey: string): Map<string, TreeNode<T>[]>;
export type TreeNode<T extends object> = {
    [K in keyof T]: T[K];
} & {
    children: TreeNode<T>[];
    isLeaf: boolean;
    parent?: TreeNode<T>;
};
export type RouteGroup<T extends object> = {
    readonly group: string;
    readonly items: TreeNode<T>[];
};
export type NodeKey = number | string | symbol | undefined | null;
export type NodeValue<T extends object, F extends (...args: any) => any> = F extends undefined ? TreeNode<T> : ReturnType<F>;
